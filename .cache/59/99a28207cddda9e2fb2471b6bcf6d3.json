{"id":"../node_modules/history/es/LocationUtils.js","dependencies":[{"name":"/home/ifat/react-bootcamp/portfolio/package.json","includedInParent":true,"mtime":1565775115676},{"name":"/home/ifat/react-bootcamp/portfolio/.babelrc","includedInParent":true,"mtime":1565267436740},{"name":"/home/ifat/react-bootcamp/portfolio/node_modules/history/package.json","includedInParent":true,"mtime":1565775115364},{"name":"resolve-pathname","loc":{"line":3,"column":28},"parent":"/home/ifat/react-bootcamp/portfolio/node_modules/history/es/LocationUtils.js","resolved":"/home/ifat/react-bootcamp/portfolio/node_modules/resolve-pathname/index.js"},{"name":"value-equal","loc":{"line":4,"column":23},"parent":"/home/ifat/react-bootcamp/portfolio/node_modules/history/es/LocationUtils.js","resolved":"/home/ifat/react-bootcamp/portfolio/node_modules/value-equal/index.js"},{"name":"./PathUtils","loc":{"line":5,"column":26},"parent":"/home/ifat/react-bootcamp/portfolio/node_modules/history/es/LocationUtils.js","resolved":"/home/ifat/react-bootcamp/portfolio/node_modules/history/es/PathUtils.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.locationsAreEqual = exports.createLocation = void 0;\n\nvar _resolvePathname = _interopRequireDefault(require(\"resolve-pathname\"));\n\nvar _valueEqual = _interopRequireDefault(require(\"value-equal\"));\n\nvar _PathUtils = require(\"./PathUtils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = (0, _PathUtils.parsePath)(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = (0, _resolvePathname.default)(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nexports.createLocation = createLocation;\n\nvar locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual.default)(a.state, b.state);\n};\n\nexports.locationsAreEqual = locationsAreEqual;"},"hash":"97a7ec0c0a0a5ee7b702287c4801f0dd","cacheData":{"env":{}}}